---
title: "2025 Day 3: Lobby"
format: html
execute:
  warning: false
---

[Link to puzzle](https://adventofcode.com/2025/day/3)

## Part 1

First, read in and parse the input file:

```{r}
read_input <- function(fname) {
  raw <- readLines(fname)
  split_strings <- strsplit(raw, "")
  lapply(split_strings, as.numeric)
}
```

Our strategy will involve combinatorics -- we will derive every pair of digits in the vector in order, then take the maximum. We then apply that function over all elements of the input list. R has a built-in combination function that returns a matrix where each column contains rows comprising each set.

```{r}
get_joltage <- function(bank) {
  # Get all combinations of 2 elements from `bank`
  # `simplify = FALSE` makes it return a list instead of a matrix
  combos <- combn(bank, 2, simplify = FALSE)
  
  # Apply a function to paste the digits together and convert to numeric
  pasted_combos <- sapply(combos, function(combo) {
    as.numeric(paste(combo, collapse = ""))
  })
  
  # Return the max value
  max(pasted_combos)
}

get_total_joltage <- function(input) {
  sum(sapply(input, get_joltage))
}
```

Then glue it all together.

```{r}
solve_part_1 <- function(fname) {
  input <- read_input(fname)
  get_total_joltage(input)
}
```

Test data:

```{r}
solve_part_1("test_input.txt")
```

That matches the example in the prompt. Now for the real data:

```{r}
solve_part_1("input.txt")
```

And that's correct! On to part 2.

## Part 2

It turns out that getting combinations of 12 digits from inputs as long as the ones in the real puzzle input would exceed my computer's memory, even using alternative implementations from **gtools** and **RcppAlgos**. I don't think I'm up to the challenge of implementing a combination function on my own, so I'm skipping this one.
