---
title: "Day 1: Calorie Counting"
format: gfm
---

## Part 1

In case the Elves get hungry and need extra snacks, they need to know which Elf to ask: they'd like to know how many Calories are being carried by the Elf carrying the most Calories. In the example above, this is `24000` (carried by the fourth Elf).

Find the Elf carrying the most calories. How many total Calories is that Elf carrying?

### Read Input

```{r}
read_input <- function(file) {
  as.numeric(readLines(file))
}
```

### Parse Input

I want to go through the list and add up the amounts until I get to an NA, then keep track of what the highest total is.

```{r}
part_1 <- function(input_data) {
  highest_total <- 0 # <1>
  running_total <- 0 # <1>
  for (i in input_data) { # <2>
    if (is.na(i)) { # <3>
      if (running_total > highest_total) { # <3>
        highest_total <- running_total # <3>
      } # <3>
      running_total <- 0 # <4>
      next # <5>
    }
    running_total <- running_total + i # <6>
  }
  if (running_total > highest_total) { # <7>
    highest_total <- running_total # <7>
  }
  highest_total
}
```
1. Initialize variables to use in the loop
2. Iterate over each element in `input_data`
3. If `is.na(i)` we know that we've reached the end of the Elf's values, so we can check the running total against the highest total that we've seen
4. Re-set the `running_total` variable to 0 so that we can start clean with the next Elf
5. We use `next` to move onto the next iteration of the loop so that we don't try to do calculations on `NA` 
6. If `!is.na(i)` then we just add the current element to the running total
7. Finally, we know that checking `is.na(i)` will not capture the elements for the last Elf in the input. So after the loop, we check one last time if `running_total > highest_total`, just to check for that last Elf.


### Test Data

```{r}
test_input <- read_input("test_input.txt")
part_1(test_input)
```

### Real Data

```{r}
real_input <- read_input("input.txt")
part_1(real_input)
```

## Part 2

### Parse Input

We can use the same input data as before and we don't need to mess with the function to read it in. What I will do now, instead of keeping track of the single highest total, I will just populate a vector with all of the totals, sort it, and then take the three highest values. I can figure out the size of vector that I need by getting the number of `NA`s and adding one -- there is an `NA` between every Elf, but none after the last one, so that has to be added on.

```{r}
part_2 <- function(input_data) {
  elf_totals <- numeric(sum(is.na(input_data)) + 1)
  
  current_elf <- 1
  running_total <- 0
  for (i in seq_along(input_data)) {
    if (i == length(input_data)) {
      running_total <- running_total + input_data[i]
      elf_totals[current_elf] <- running_total
    }
    if (is.na(input_data[i])) {
      elf_totals[current_elf] <- running_total
      running_total <- 0
      current_elf <- current_elf + 1
      next
    }
    running_total <- running_total + input_data[i]
  }
  sum(sort(elf_totals, decreasing = TRUE)[1:3])
}
part_2(test_input)
```

### Test Data
```{r}
part_2(test_input)
```

### Real Data

```{r}
part_2(real_input)
```

