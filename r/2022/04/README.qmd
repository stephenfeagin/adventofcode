---
title: "Advent of Code: 2022 Day 4 in R"
date: 2023-09-08
categories:
  - r
  - advent of code
  - puzzle
format: gfm
---

## Day 4: Camp Cleanup

## Part 1

> In how many assignment pairs does one range fully contain the other?

I will warn you that this post will show exactly how I'm exploring the problem and all the intermediate steps -- it's not a polished report on the end product. The first challenge here is reading in the data in a way that makes it useful to us. We can first get the lines:

```{r}
test_data <- readLines("test_input.txt")
test_data
```

Next, we need to split out each line into the two Elves.

```{r}
elf_list <- strsplit(test_data, ",")
elf_list
```
We can further get each elf's range by splitting up the strings again. Here we have a list where each item in the list is a list of two 2-item vectors, each representing the start and end of each area for each elf.
```{r}
elf_list_ranges <- lapply(elf_list, strsplit, split = "-")
elf_list_ranges
```
At this point I might switch over to manually iterating. I'm going to pull out just one pair for now to play around with.
```{r}
pair <- elf_list_ranges[[1]]
for (range in pair) {
  print(readr::parse_number(range))
}
```
Now I need to convert that into sequences covering those points.

```{r}
pair_ranges <- vector("list", 2)
for (i in seq_along(pair)) {
  range_numeric <- readr::parse_number(pair[[i]])
  area_range <- seq(range_numeric[1], range_numeric[2])
  pair_ranges[[i]] <- area_range
}
pair_ranges
```
Ok, that looks promising. Now I just have to check whether either range completely includes the other.

```{r}
all(pair_ranges[[1]] %in% pair_ranges[[2]]) || all(pair_ranges[[2]] %in% pair_ranges[[1]])
```
Not bad. Now I have to put that all together and iterate over the list of lists.

```{r}
get_character_list <- function(input_data) {
  strsplit(input_data, ",") |> 
    lapply(strsplit, split = "-")
}
character_list <- get_character_list(test_data)
character_list
```

```{r}
get_area_ranges <- function(character_list) {
  all_pairs <- vector("list", length(character_list)) # <1>
  for (i in seq_along(character_list)) { # <2>
    pair_ranges <- vector("list", 2) # <3>
    for (j in 1:2) {  # <4>
      endpoints <- readr::parse_number(character_list[[i]][[j]]) # <5>
      area <- seq(from = endpoints[1], to = endpoints[2]) # <6>
      pair_ranges[[j]] <- area # <6>
    }
    all_pairs[[i]] <- pair_ranges # <7>
  }
  all_pairs
}
area_ranges <- get_area_ranges(character_list)
```
1. Initialize an empty list to hold the results
2. Iterate over the pairs of elves
3. Initialize a list to contain each pair's ranges
4. I know there are only 2 vectors in each list, one for each elf, so I can hardcode `1:2`
5. Turn the character strings into numeric values
6. Generate the sequence and populate the `pair_ranges` list
7. Populate the `all_pairs` list

```{r}
area_ranges
```


```{r}
check_overlap <- function(ranges) {
  all(ranges[[1]] %in% ranges[[2]]) || all(ranges[[2]] %in% ranges[[1]])
}
sapply(area_ranges, check_overlap)
```

Now to put it all together.

```{r}
part_1 <- function(input_data) {
  input_data |> 
    get_character_list() |> 
    get_area_ranges() |> 
    sapply(check_overlap) |> 
    sum()
}
part_1(test_data)
```

That's the correct answer for the example. Now to try it on the real thing:

```{r}
real_data <- readLines("input.txt")
part_1(real_data)
```
That's the right answer! One gold star!

## Part 2

This should be easy. All I have to do is change `check_overlap()` to see if there is `any()` overlap instead of `all()`.

```{r}
check_any_overlap <- function(ranges) {
  any(ranges[[1]] %in% ranges[[2]]) || any(ranges[[2]] %in% ranges[[1]])
}
```

Put it together again:

```{r}
part_2 <- function(input_data) {
  input_data |> 
    get_character_list() |> 
    get_area_ranges() |> 
    sapply(check_any_overlap) |> 
    sum()
}
part_2(test_data)
```

Real data:

```{r}
part_2(real_data)
```

And that's correct!

You can find all of my Advent of Code solutions on [GitHub](https://github.com/stephenfeagin/adventofcode).
